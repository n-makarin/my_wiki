# Ownership

## Table of Contents

- [Ownership](#ownership)
  - [Table of Contents](#table-of-contents)
  - [Main rules](#main-rules)
  - [The Stack and the Heap](#the-stack-and-the-heap)
  - [Variable Scope](#variable-scope)
  - [The String Type](#the-string-type)
  - [Memory and Allocation](#memory-and-allocation)
  - [Move](#move)

## Main rules

- Each value in Rust has a variable thatâ€™s called its owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

## The Stack and the Heap

All simple values with a known fixed values are pushed onto the stack.

All sdk and created types are pushed onto the heap.

## Variable Scope

A scope is the range within a program for which an item is valid.

## The String Type

```rust
fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!");

    println!("{}", s); // This will print `hello, world!`
}
```

## Memory and Allocation

- The memory must be requested from the memory allocator at runtime.

  Starts when we call String::from
  
- We need a way of returning this memory to the allocator when weâ€™re done with our String.

**allocate** - allocate memory

**free** - free memory

**drop** - itâ€™s where the author of String can put the code to return the memory. Rust calls drop automatically at the closing curly bracket.

## Move

Representation in memory of a String holding the value "hello" bound to s1.

A String is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity.

This group of data is stored on the stack.

On the right is the memory on the heap that holds the contents.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
}
```
<!-- markdownlint-disable MD033 -->
<img src="/img/prog/lang/rust/string_in_heap.svg" width="375" alt="representation in memory">

**ptr** - pointer refers to a data in heap

**length** - is how much memory, in bytes, the contents of the String is currently using.

**capacity** - the total amount of memory, in bytes, that the String has received from the allocator

When we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack.

We do not copy the data on the heap that the pointer refers to.
<!-- markdownlint-disable MD033 -->
<img src="/img/prog/lang/rust/move_string.svg" width="375" alt="move string">

Both data pointers pointing to the same location. This is a problem: when s2 and s1 go out of scope, they will both try to free the same memory.

ðŸ”¹ Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and, therefore, Rust doesnâ€™t need to free anything when s1 goes out of scope.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
    // error: could not compile `ownership`.
}
```
